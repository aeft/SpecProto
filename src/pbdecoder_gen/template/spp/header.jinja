#ifndef __{{ proto_file_prefix.upper() }}_SPP_H__
#define __{{ proto_file_prefix.upper() }}_SPP_H__
#include <iostream>
#include <string>
#include <vector>

#include "{{ proto_file_prefix }}.pb.h"
#include "../../src/cpp/lib.h"

namespace {{ namespace }} {

const uint32_t MAX_EXTRA_BYTES = 10000;
{# extern uint32_t REDO_BYTE_STAT; #}

enum class PType {
{%- for ptype, id in ptypes %}
    {{ ptype }}  = {{ id }},
{%- endfor %}
};

static std::unordered_map<uint32_t, std::vector<PType>> CandidatesInit = {
    {%- for tag, lst in candidates_init.items() %}
    { {{- tag }}, { {%- for ptype in lst %}PType::{{ ptype }}{{ ", " if not loop.last else "" }}{%- endfor -%} {% raw %}}}{% endraw %},
    {%- endfor %}
};

static std::unordered_map<PType, std::unordered_map<uint32_t, std::vector<PType>>> Candidates = {
    {%- for psrc, out in candidates.items() %}
    {PType::{{ psrc }}, {
        {%- for tag, lst in out.items() %}
        { {{- tag }}, { {%- for ptype in lst %}PType::{{ ptype }}{{ ", " if not loop.last else "" }}{%- endfor -%} {% raw %}}}{% endraw %},
        {%- endfor %}
    {% raw %}}}{% endraw %},
    {%- endfor %}
};

static std::unordered_map<PType, std::unordered_map<uint32_t, PType>> MergeTypeCheck = {
    {%- for psrc, out in merge_type_check.items() %}
    {PType::{{ psrc }}, {
        {%- for tag, ptype in out.items() %}
        { {{- tag }}, PType::{{ ptype }}},
        {%- endfor %}
    {% raw %}}}{% endraw %},
    {%- endfor %}
};

class _Base {
   public:
    virtual ~_Base() = default;  
};

struct IR {
    uint32_t tag;
    uint32_t start;  // the first byte of tag
    uint32_t end;    // the last byte of value + 1
    _Base* value = nullptr;

    PType *pcur, *pend;

    IR() {}

    IR(uint32_t tag, uint32_t start, uint32_t end, _Base* value, PType* pcur, PType* pend)
        : tag(tag), start(start), end(end), value(value), pcur(pcur), pend(pend) {}

    IR(IR&& other) noexcept
        : tag(other.tag),
          start(other.start),
          end(other.end),
          value(other.value),
          pcur(other.pcur),
          pend(other.pend) {
        other.value = nullptr;
    }

    ~IR() { delete value; }
};

struct TagInfo {
    uint32_t tag;
    uint32_t start;
    uint32_t end;

    TagInfo(uint32_t tag, uint32_t start, uint32_t end)
        : tag(tag), start(start), end(end) {}
};

struct FallbackInfo {
    uint32_t fallback_pos;
    uint32_t start;
    PType *pcur, *pend;

    FallbackInfo(uint32_t fallback_pos, uint32_t start, PType* pcur, PType* pend)
        : fallback_pos(fallback_pos), start(start), pcur(pcur), pend(pend) {}
};

{%- for ptype, cpp_type in primary_ptype_mapping.items() %}
class {{ ptype }} : public _Base {
   public:
    {{ cpp_type }} v;
    {{ ptype }}() {}
};
{%- endfor %}

{% for name in messages.keys() %}
class {{ name }};
{%- endfor %}

{% for message_name, fields in messages.items() %}
class {{ message_name }} : public _Base {
   public:
    {%- for field in fields %}
    {{ field.cpp_type }} {{ field.name }};
    {%- endfor %}
    {{ message_name }}();
    ~{{ message_name }}();
    {%- if message_name == main_message_name %}
    bool Parse(ByteStream&); // user call this
    bool ParsePartial(ByteStream&, std::vector<IR>&, std::vector<FallbackInfo>&, std::deque<TagInfo>&, uint32_t);
    {%- endif %}
    bool Parse(ByteStream&, std::deque<TagInfo>&, uint32_t&, bool&, uint32_t);
    inline bool ParseOnce(ByteStream&, std::deque<TagInfo>&, uint32_t&, bool&, uint32_t);
    bool Merge(ByteStream&, std::deque<TagInfo>&, uint32_t&, std::vector<IR>&, uint32_t&, bool&, bool&, uint32_t);
    PB::{{ message_name }}* ConvertToPB(PB::{{ message_name }}*);
};
{%- endfor %}

}
#endif